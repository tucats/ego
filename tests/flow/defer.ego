@test "flow: defer statement"
{
    func defer_test() string {
        var r string 

        defer func(){ 
            r = "better result"
        }()

        r = "result string"
        return r

    }

    result := defer_test() 
    @assert T.Equal(result, "better result")
}

// This second test is to ensure that the defer statement is not
// executed at end of the function unless the defer was itself
// executed. The boolean flag indicates which defer statement is
// actually executed, so the exit point of the function will test
// to see which, if any, defer statement was actually executed.
{
    func defer_test(flag int) string {
        var r string 

        switch flag {
        case 1:
			defer func(){ 
				r = "better result - true"
			}()

        case 2:
			defer func(){ 
				r = "better result - false"
			}()
        }

        r = "result string"
        
        return r

    }

    result := defer_test(1) 
    @assert T.Equal(result, "better result - true")

    result = defer_test(2) 
    @assert T.Equal(result, "better result - false")

    // The value zero means no defer statement is executed at all.
    result = defer_test(0)
    @assert T.Equal(result, "result string")
}

// This test confirms that the symbol resolution for defer function
// arguments happens correctly.
{
    func defer_test() string {
        var r string 
        var x string 

        x = "good"
        defer func(x string) {
            r = "better result: " + x
        }(x)

        x = "bad"
        return r

    }

    result := defer_test() 
    @assert T.Equal(result, "better result: good")

}


// This test confirms that the symbol resolution for non-defer-local values
// happens correctly.
{
    func defer_test() string {
        var r string 
        var x string 

        x = "bad"
        defer func() {
            r = "better result: " + x
        }()

        x = "good"
        return r

    }

    result := defer_test() 
    @assert T.Equal(result, "better result: good")

}