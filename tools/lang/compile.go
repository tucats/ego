package main

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func compile(path, source, digest string) {
	messages := make(map[string]map[string]string)

	// Make a list of the files in the path directory that match the "messages_*.txt" pattern.
	files, err := os.ReadDir(path)
	if err != nil {
		panic(err)
	}

	for _, file := range files {
		if file.IsDir() {
			continue
		}

		if !file.Type().IsRegular() {
			continue
		}

		if !file.Type().IsRegular() {
			continue
		}

		if !strings.HasPrefix(file.Name(), "messages_") {
			continue
		}

		if !strings.HasSuffix(file.Name(), ".txt") {
			continue
		}

		lang := strings.TrimPrefix(file.Name(), "messages_")
		lang = strings.TrimSuffix(lang, ".txt")

		name := filepath.Join(path, file.Name())
		compileFile(name, lang, messages)
	}

	doWrite := false

	// If the digest file does not exist, create it.
	if _, err := os.Stat(digest); os.IsNotExist(err) {
		if err := os.WriteFile(digest, []byte(digestValue(path)), 0644); err != nil {
			fmt.Println(err)
			os.Exit(1)
		}

		doWrite = true
	} else {
		// See if the existing digest value matches the current value in the
		// digest file.
		if data, err := os.ReadFile(digest); err != nil {
			fmt.Println(err)
			os.Exit(1)
		} else {
			//  Convert the existing digest value to a base64 string. If it
			// matches the existing digest, then we don't need to write the
			// output file. Otherwise, update the digest file with the new
			// value.
			if string(data) != digestValue(path) {
				if err := os.WriteFile(digest, []byte(digestValue(path)), 0644); err != nil {
					fmt.Println(err)
					os.Exit(1)
				}

				doWrite = true
			}
		}
	}

	if doWrite {
		source, _ = filepath.Abs(source)
		fmt.Println("Generating " + source)

		// Create the source file.
		file, err := os.Create(source)
		if err != nil {
			panic(err)
		}

		// Write the header.
		fmt.Fprintf(file, "package i18n\n\n")
		fmt.Fprintf(file, "// Code generated by lang tool; DO NOT EDIT.\n\n")

		fmt.Fprintf(file, "var messages = map[string]map[string]string{\n")

		// Make alphabetically sorted list of the keys.
		var keys []string
		for key := range messages {
			keys = append(keys, key)
		}

		sort.Strings(keys)

		// Scan over the messages map and write each element to the string constant,
		// using the sorted key list.
		for _, key := range keys {
			m := messages[key]
			fmt.Fprintf(file, "\t%q: {\n", key)

			// Make alphabetically sorted list of the languages.
			var langs []string
			for lang := range m {
				langs = append(langs, lang)
			}

			sort.Strings(langs)

			// Scan over the languages and write each element to the string constant,
			// using the sorted language list.
			for _, lang := range langs {
				message := m[lang]
				fmt.Fprintf(file, "\t\t%q: %q,\n", lang, message)
			}

			fmt.Fprintf(file, "\t},\n")
		}

		fmt.Fprintf(file, "}\n")

		file.Close()
	}
}

func compileFile(filename, language string, messages map[string]map[string]string) {
	var prefix string

	if logging {
		fmt.Printf("Compiling %s\n", filename)
	}

	// Read the file into a buffer and split into lines separated by '\n'.
	b, err := os.ReadFile(filename)
	if err != nil {
		panic(err)
	}

	_ = addFileToDigest(filename, b)

	// Split the file contents into an array of strings
	lines := strings.Split(string(b), "\n")

	for lineNumber, line := range lines {
		// Skip comments.
		if strings.HasPrefix(line, "#") {
			continue
		}

		// Skip blank lines.
		line = strings.TrimSpace(line)
		if len(line) == 0 {
			continue
		}

		// Is it a new prefix key?
		if strings.HasPrefix(line, "[") {
			if !strings.HasSuffix(line, "]") {
				panic(fmt.Sprintf("%s:%d: Malformed prefix line\n", filename, lineNumber))
			}

			prefix = line[1 : len(line)-1]

			continue
		}

		// Split the line into the key and the message.
		i := strings.Index(line, "=")
		if i < 0 {
			panic(fmt.Sprintf("%s:%d: Malformed line\n", filename, lineNumber))
		}

		key := line[:i]
		message := line[i+1:]

		if prefix != "" {
			key = prefix + "." + key
		}

		// Create a map for the key if it doesn't already exist.
		if _, ok := messages[key]; !ok {
			messages[key] = make(map[string]string)
		}

		// Add the message to the map.
		messages[key][language] = message
	}
}
