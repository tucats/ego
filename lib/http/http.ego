
package http

type Request struct {
    Method         string
    Url            string 
    Endpoint       string
    Media          string
    Headers        map[string][]string 
    Parameters     map[string][]string
    Authentication string
    Username       string
    Body           string
}

type Response struct {
	Status         int
	Buffer         string
}

func (r *Response) WriteStatus(status int) {
	@status status
}
func (r *Response) Write(item interface{}) {
	@response item
}

func (r *Response) WriteMessage(msg string) {
    @text {
        @response msg
    }
    @json {
        m := {message: msg}
        @response m
    }
}

func (r *Response) WriteJSON( i interface{}) {
	msg := json.Marshal(i)
	r.Write(msg)
}

func (r *Response) WriteTemplate( fn string, i interface{}) {

    try {
        // Load the page file as a template
        fn := filepath.Join(profile.Get("ego.runtime.path"), fn)
        @template mempage io.ReadFile(fn)

        // Render the page using the dynamic data, and return it as the response
        page := strings.Template(mempage, pageData)
        resp.Write(page)
    } catch(e) {
        resp.Status(500)
        resp.WriteMessage(e)
    }
}


func BadURL(url string) {
    @status 400
    @response "Unrecognized URI path " + url
}

func NewResponse() Response {
	r := Response{
		Status:   200,
	}

	return r
}

func NewRequest() Request {
    r := Request{
        Url:             _url,
        Endpoint:        _path_endpoint,
        Headers:         _headers,
        Parameters:      _parms,
        Method:          _method,
        Body:            _body,
    }

    if _json {
        r.Media = "json"
    } else {
        r.Media = "text"
    }

    if _authenticated {
        if _token == "" {
            r.Authentication = "basic"
            r.Username = _user
        } else {
            r.Authentication = "token"
            r.Username = _user
        }
    } else {
        r.Authentication = "none"
    }
    return r
}
