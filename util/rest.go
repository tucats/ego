package util

import (
	"encoding/json"
	"net/http"
	"strings"

	"github.com/tucats/ego/app-cli/ui"
	"github.com/tucats/ego/defs"
)

// MakeServerInfo creates a server info object for the current server instance
// and the given session ID value. (Session ID is an integer value that uniquely
// identifies the web service call to this server instance.) The resulting header
// can be encoded as JSON and included in the HTTP response body.
func MakeServerInfo(sessionID int) defs.ServerInfo {
	hostName := Hostname()
	result := defs.ServerInfo{
		Hostname: hostName,
		ID:       defs.InstanceID,
		Session:  sessionID,
		Version:  defs.APIVersion,
	}

	return result
}

// MakeBaseCollection creates a base collection object for the current server instance
// that can be returned as a response to a client request. This collection object is
// incomplete; the caller should fill in the additional count and start values.
func MakeBaseCollection(sessionID int) defs.BaseCollection {
	result := defs.BaseCollection{
		ServerInfo: MakeServerInfo(sessionID),
		Status:     http.StatusOK,
	}

	return result
}

// ErrorResponse returns an error response to the client with the given session ID,
// message, and status code. The error response is encoded as JSON and written as
// the HTTP response body. Additionally, the HTTP headers indicating the status code
// is set in the response and is returned as the function value. This is intended
// to be used as the exit operation from a REST API handler when an error occurs.
func ErrorResponse(w http.ResponseWriter, sessionID int, msg string, status int) int {
	response := defs.RestStatusResponse{
		ServerInfo: MakeServerInfo(sessionID),
		Message:    msg,
		Status:     status,
	}

	if status < 100 || status >= 600 {
		status = http.StatusInternalServerError
	}

	// Remove noise from postgres errors, which all have a "pq: " prefix which we want
	// to remove from the error message text -- no need to indicate that we're using
	// postgres for some underlying functionality.
	msg = strings.TrimPrefix(msg, "pq: ")
	msg = strings.Replace(msg, " pq: ", "", 1)

	// Construct a neatly formatted JSON response.
	b, _ := json.MarshalIndent(response, ui.JSONIndentPrefix, ui.JSONIndentSpacer)

	// Add the Content-Type header to indicate we are sending back an error response.
	w.Header().Add(defs.ContentTypeHeader, defs.ErrorMediaType)

	// Write the error response to the HTTP response body.
	w.WriteHeader(status)

	// Write the JSON-encoded error response to the HTTP response body.
	_, _ = w.Write(b)

	// If the REST logger is active log the message to the log along with a text representation
	// of the JSON error response payload.
	if ui.IsActive(ui.RestLogger) {
		logMessageKey := "rest.error"
		if status < 299 {
			logMessageKey = "rest.success"
		}

		ui.Log(ui.RestLogger, logMessageKey, ui.A{
			"session": sessionID,
			"error":   msg,
			"status":  status})
		ui.WriteLog(ui.RestLogger, "rest.response.payload", ui.A{
			"session": sessionID,
			"body":    string(b)})
	}

	return status
}

// For a given HTTP header, return true if this header contains non-sensitive information, and
// can be reported in a log or copied to a filesystem location that could be potentially read
// by others.
//
// The intent is to prevent headers containing authorization, security policy, cookies, or other
// sensitive information from being exposed outside the server memory.
func NonSensitiveHeader(text string) bool {
	// This is a list of headers we are allowed to report in the log for REST
	// operations.
	var nonSensitiveRestHeaders = map[string]bool{
		"accept":            true,
		"accept-encoding":   true,
		"accept-language":   true,
		"accept-range":      true,
		"accept-signature":  true,
		"cache-control":     true,
		"content-digest":    true,
		"content-length":    true,
		"content-location":  true,
		"content-md5":       true,
		"content-range":     true,
		"content-type":      true,
		"date":              true,
		"prefer":            true,
		"range":             true,
		"user-agent":        true,
		"from":              true,
		"via":               true,
		"x-forwarded-for":   true,
		"x-forwarded-proto": true,
		"x-real-ip":         true,
		"host":              true,
		"allow":             true,
	}

	key := strings.ToLower(text)

	// IF the name starts with "X-" then it is an extension header, and it could contain any
	// value generated by the user.
	if strings.HasPrefix(key, "x-") {
		return true
	}

	return nonSensitiveRestHeaders[key]
}
