package bytecode

import (
	"reflect"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/tucats/ego/app-cli/settings"
	"github.com/tucats/ego/app-cli/ui"
	"github.com/tucats/ego/data"
	"github.com/tucats/ego/defs"
	"github.com/tucats/ego/errors"
	"github.com/tucats/ego/symbols"
	"github.com/tucats/ego/tokenizer"
)

// For a function call with a receiver, this is the structure that
// describes the receiver's name and current value.
type this struct {
	// The name of the receiver variable
	name string

	// The current value of the receiver variable when a function call
	// is made. We save it here because the symbol scope stack changes
	// during a function call so the current value may not be accessible
	// when needed in the scope of the called function.
	value any
}

// For a given try/catch block, this is the runtime info needed for the exception
// handler to know if a catch clause is to be invoked.
type tryInfo struct {
	// Branch destination in a try/catch block where execution transfers
	// to handle the catch clause.
	addr int

	// List of errors that the catch block is able to handle.
	catches []error
}

// This value is updated atomically during context creation.
var nextThreadID int32 = 0

// MaxStackSize records the largest stack size encountered during a
// stack push operation. This can be used to determine if the initial
// stack size is adequate.
var MaxStackSize int32

// InstructionsExecuted counts the number of byte code instructions
// executed.
var InstructionsExecuted int64

// deferStatement is a structure that holds the information about a
// defer statement previously processed.
type deferStatement struct {
	// Source location
	name string

	// Function target
	target any

	// Receiver stack in effect for this defer statement
	receiverStack []this

	// Symbols active for this defer statement
	symbols *symbols.SymbolTable

	// Arguments
	args []any
}

// Context holds the runtime information about an instance of bytecode being
// executed.
type Context struct {
	// Name of the function currently being executed
	name string

	// Package name of the function currently being executed. If not running
	// within a package, this is an empty string.
	pkg string

	// Module name for the current function. This is typically the base part
	// of the source file containing the function being execute. When running
	// interactively in REPL mode, this is always an empty string.
	module string

	// The bytecode array currently being executed.
	bc *ByteCode

	// The active symbol table for the current function.
	symbols *symbols.SymbolTable

	// The pointer to the tokenizer for the source code being executed. This
	// is only used for error handling or when the debugger is active.
	tokenizer *tokenizer.Tokenizer

	// The runtime stack. The stack is a LIFO stack that supports the RPN
	// execution mode of expressions as generated by the Ego compiler.
	stack []any

	// This is a list of the nested try/catch blocks. When entering a new
	// try/catch block, a new tryInfo is pushed onto this stack. When an
	// exception occurs, the stack is searched to see if a catch block
	// is defined for the current exception. When exiting the try/catch block,
	// the tryInfo is popped from the stack.
	tryStack []tryInfo

	// The range stack is used for managing nested for loops. Each loop type
	// creates a range definition object, and is pushed on the stack. When the
	// end of loop is hit, the range definition object is re-evaluated and if
	// the loop conditions is satisfied, the loop is exited and the range definition
	// object is popped from the stack.
	rangeStack []*rangeDefinition

	// The timer stack is used to manage timed operations.
	timerStack []time.Time

	// The current value of the "this" variable. This is used when a function call
	// is made to a method that has a receiver. The current function may be executed
	// as a result of nested receiver invocations (such as a.b.c.d(), for example).
	// This stack manages the current this value, and at the end of the function call,
	// the current this value is popped from the stack.
	receiverStack []this

	// This manages the list of defer statements. Each defer statement generates code
	// and context information for it's execution. Defer operations are executed in the
	// order they were added, and the execution of the defer statements is performed
	// when the function call returns.
	deferStack []deferStatement

	// If text output (from fmt.Println(), etc) is being captured rather than sent
	// directly to the stdout, it is written to this string buffer. For example, when
	// running a REST function that captures output as the result of the API call.
	// If immediate output is active, this pointer is nil.
	output *strings.Builder

	// The function result is stored here if there is a return statement with a
	// result value. If there are multiple return values, this is an array slice
	// of values.
	result any

	// Mutex to protect context updates during concurrent execution. For example,
	// if the context is for a function that invokes go routine(s), those routines
	// may need to update this context... the mutex is used to ensure that only one
	// goroutine can update the context at a time.
	mux sync.RWMutex

	// If there is a go routine associated with this context, this is the error state
	// if any.
	goErr error

	// This contains the text of the executing code. This is used by the debugger, and
	// is normally an empty string during non-debug mode.
	source string

	// The current bytecode instruction being executed, zero-based.
	programCounter int

	// The current stack pointer value in the stack slide.
	stackPointer int

	// The pointer within the current stack where the current function call's frame information
	// is stored. A frame is the information needed to update the context when the function
	// returns (restoring the caller's stack pointer, program counter, etc.) A
	framePointer int

	// The line number of the current source code being executed. This is updated by the
	// _Line bytecode and is used by the debugger and to formulate error messages.
	line int

	// The line number of the last line of source that was output during execution
	// tracing.
	lastLine int

	// The nested scope depth of the current symbol table. A depth of zero means no
	// symbol tables have been pushed on the symbol table stack.
	blockDepth int

	// This is an offset in the argument count used to get arguments from the stack
	// during a call. Normally this value is zero, but if the runtime requires adding
	// additional information to the call (such as an the invocation of a goroutine)
	// this value may be a positive non-zero value.
	argCountDelta int

	// If non-zero, it means the defer item we are executing at the moment has receiver
	// items associated with the defer invocation.
	deferThisSize int

	// The pointer to the symbol table stack active at the time when the current defer
	// block was created. The runtime context of a defer must be able to access the local
	// symbol value sat the time of the defer.
	deferSymbols *symbols.SymbolTable

	// An internal numeric unique value indicating the current thread number. This is not
	// related to operating system or Go thread id values. It is used to uniquely identify
	// each Ego thread running a go routine.
	threadID int32

	// If true, then symbol access for this context is allowed to see all nested symbol tables
	// above it, even if they are normally considered private. This is used to support debugger
	// and specific runtime functions that are allowed to display symbol table data.
	fullSymbolScope bool

	// If true, the current bytecode is running, and at the completion of each bytecode will
	// fetch the next instruction. When the bytecode stream is done executing, this is set
	// to false.
	running bool

	// Indicator of the type strictness for this context. Each new context inherits the
	// type strictness of the parent context. However, the code cah change the strictness
	// within a given context (some of the runtime packages do this when they need to be
	// type independent, for example).
	typeStrictness int

	// If true, the context is being used for debugging. When set, each _Line bytecode
	// causes control to return to the debugger REPL to allow the debugger to determine
	// if there is a breakpoint or step operation that is active that would result in a
	// prompt to the user. If no step or breakpoint is active, the debugger resumes the
	// execution of the bytecode at the next bytecode after the _Line.
	debugging bool

	// When true, this bytecode is in single-step mode and control returns to the debugger
	// after each _Line bytecode.
	singleStep bool

	// If true, control returns to the debugger after each _Return bytecode.
	breakOnReturn bool

	// IF true, control does NOT return to the debugger when calling into another
	// bytecode function.
	stepOver bool

	// When true, try/catch will not catch any errors not enumerated in the catch
	// statement. If false, then all errors go to the catch block.
	throwUncheckedErrors bool

	// When an error occurs, does the full stack get printed int he trace, or only the
	// first few items. This is normally off, but for complicated debugging situations it
	// may be helpful to see the entire stack at each statement or bytecode instruction.
	fullStackTrace bool

	// When true, each bytecode is traced, including the bytecode name and source line.
	tracing bool

	// When true, language extensions are enabled.
	extensions bool

	// When true, this context is shared by multiple goroutines. This causes some operations
	// to perform additional serialization.
	shared bool
}

// NewContext generates a new context. It must be passed a symbol table and a bytecode
// array. A context holds the runtime state of a given execution unit (program counter,
// runtime stack, symbol table) and is used to actually run bytecode. The bytecode
// can continue to be modified after it is associated with a context.
func NewContext(s *symbols.SymbolTable, b *ByteCode) *Context {
	var err error

	// Make sure globals are initialized.
	initializeDispatch()

	// Determine the name using the associated ByteCode object.
	name := ""
	if b != nil {
		name = b.name
	}

	// Determine whether static data typing is in effect. This is
	// normally off, but can be set by a global variable (which is
	// ultimately set by a profile setting or CLI option).
	static := defs.NoTypeEnforcement

	if s, found := s.Get(defs.TypeCheckingVariable); found {
		if static, err = data.Int(s); err != nil {
			ui.Log(ui.InternalLogger, "runtime.typing.error", ui.A{
				"name":  defs.TypeCheckingVariable,
				"error": err})
		}

		if static < defs.StrictTypeEnforcement || static > defs.NoTypeEnforcement {
			static = defs.NoTypeEnforcement
		}
	}

	// If we weren't given a table, create an empty temp table.
	if s == nil {
		s = symbols.NewSymbolTable("")
	}

	extensions := false

	if v, ok := s.Root().Get(defs.ExtensionsVariable); ok {
		if extensions, err = data.Bool(v); err != nil {
			ui.Log(ui.InternalLogger, "runtime.extensions.error", ui.A{
				"name":  defs.ExtensionsVariable,
				"error": err})
		}
	}

	// Create the context object.
	ctx := Context{
		name:                 name,
		threadID:             atomic.AddInt32(&nextThreadID, 1),
		bc:                   b,
		programCounter:       0,
		stack:                make([]any, initialStackSize),
		stackPointer:         0,
		framePointer:         0,
		running:              false,
		typeStrictness:       static,
		line:                 0,
		symbols:              s,
		fullSymbolScope:      true,
		receiverStack:        nil,
		deferStack:           make([]deferStatement, 0),
		throwUncheckedErrors: settings.GetBool(defs.ThrowUncheckedErrorsSetting),
		fullStackTrace:       settings.GetBool(defs.FullStackTraceSetting),
		tryStack:             make([]tryInfo, 0),
		rangeStack:           make([]*rangeDefinition, 0),
		timerStack:           make([]time.Time, 0),
		tracing:              false,
		extensions:           extensions,
	}
	contextPointer := &ctx
	contextPointer.SetByteCode(b)

	return contextPointer
}

// GetName returns the name of the module currently executing.
func (c *Context) GetName() string {
	if c.bc != nil {
		return c.bc.name
	}

	return defs.Main
}

// GetLine retrieves the current line number from the
// original source being executed. This is stored in the
// context every time an AtLine instruction is executed.
func (c *Context) GetLine() int {
	c.mux.RLock()
	defer c.mux.RUnlock()

	return c.line
}

// Set the extensions mode explicitly for the context.
func (c *Context) SetExtensions(b bool) *Context {
	c.extensions = b

	return c
}

// SetDebug turns debugging mode on or off for the current
// context.
func (c *Context) SetDebug(b bool) *Context {
	c.debugging = b
	c.singleStep = true

	return c
}

// SetFullSymbolScope sets the flag that indicates if a
// symbol table read can "see" a symbol outside the current
// function. The default is off, which means symbols are not
// visible outside the function unless they are in the global
// symbol table. If true, then a symbol can be read from any
// level of the symbol table parentage chain.
func (c *Context) SetFullSymbolScope(b bool) *Context {
	c.fullSymbolScope = b

	return c
}

// SetPC sets the program counter (PC) which indicates the
// next instruction number to execute.
func (c *Context) SetPC(pc int) *Context {
	c.programCounter = pc

	return c
}

// SetGlobal stores a value in a the global symbol table that is
// at the top of the symbol table chain.
func (c *Context) SetGlobal(name string, value any) error {
	return c.symbols.Root().Set(name, value)
}

// EnableConsoleOutput tells the context to begin capturing all output normally generated
// from Print and Newline into a buffer instead of going to stdout.
func (c *Context) EnableConsoleOutput(flag bool) *Context {
	ui.Log(ui.AppLogger, "app.console.enable", ui.A{
		"flag": flag})

	if !flag {
		c.output = &strings.Builder{}
	} else {
		c.output = nil
	}

	return c
}

// GetOutput retrieves the output buffer. This is the buffer that
// contains all Print and related bytecode instruction output. This
// is used when output capture is enabled, which typically happens
// when a program is running as a Web service.
func (c *Context) GetOutput() string {
	if c.output != nil {
		return c.output.String()
	}

	return ""
}

// Tracing returns the trace status of the current context. When
// tracing is on, each time an instruction is executed, the current
// instruction and the top few items on the stack are printed to
// the console.
func (c *Context) Tracing() bool {
	return ui.IsActive(ui.TraceLogger)
}

// SetTokenizer sets a tokenizer in the current context for use by
// tracing and debugging operations. This gives those functions
// access to the token stream used to compile the bytecode in this
// context.
func (c *Context) SetTokenizer(t *tokenizer.Tokenizer) *Context {
	c.tokenizer = t

	return c
}

// GetSource returns the stored source line (if any) in the
// current context.
func (c *Context) GetSource() string {
	return c.source
}

// GetTokenizer gets the tokenizer in the current context for
// tracing and debugging.
func (c *Context) GetTokenizer() *tokenizer.Tokenizer {
	return c.tokenizer
}

// AppendSymbols appends a symbol table to the current context.
// This is used to add in compiler maps, for example.
func (c *Context) AppendSymbols(s *symbols.SymbolTable) *Context {
	for _, name := range s.Names() {
		value, _ := s.Get(name)
		c.symbols.SetAlways(name, value)
	}

	return c
}

// SetByteCode attaches a new bytecode object to the current run context.
func (c *Context) SetByteCode(b *ByteCode) *Context {
	c.bc = b

	return c
}

// SetSingleStep enables or disables single-step mode. This has no
// effect if debugging is not active.
func (c *Context) SetSingleStep(b bool) *Context {
	c.singleStep = b

	return c
}

// SingleStep retrieves the current single-step setting for this
// context. This is used in the debugger to know how to handle
// break operations.
func (c *Context) SingleStep() bool {
	return c.singleStep
}

// SetStepOver determines if single step operations step over a
// function call, or step into it.
func (c *Context) SetStepOver(b bool) *Context {
	c.stepOver = b

	return c
}

// GetModuleName returns the name of the current module (typically
// the function name or program name).
func (c *Context) GetModuleName() string {
	return c.bc.name
}

// PopValue removes the top-most item from the stack and returns it.
// If the item was an immutable constant value, the value is unwrapped
// before returning it.
func (c *Context) Pop() (any, error) {
	v, err := c.PopWithoutUnwrapping()
	if err == nil {
		if c, ok := v.(data.Immutable); ok {
			v = c.Value
		}
	}

	return v, err
}

// Pop removes the top-most item from the stack.
func (c *Context) PopWithoutUnwrapping() (any, error) {
	if c.stackPointer <= 0 || len(c.stack) < c.stackPointer {
		return nil, c.runtimeError(errors.ErrStackUnderflow)
	}

	c.stackPointer = c.stackPointer - 1
	value := c.stack[c.stackPointer]

	return value, nil
}

// Helper function that retrieves the symbol table for the running context.
func (c *Context) GetSymbols() *symbols.SymbolTable {
	return c.symbols
}

// setConstant is a helper function to define a constant value.
func (c *Context) setConstant(name string, v any) error {
	return c.symbols.SetConstant(name, v)
}

// isConstant is a helper function to define a constant value.
func (c *Context) isConstant(name string) bool {
	return c.symbols.IsConstant(name)
}

// get is a helper function that retrieves a symbol value from the associated
// symbol table.
func (c *Context) get(name string) (any, bool) {
	return c.symbols.Get(name)
}

// set is a helper function that sets a symbol value in the associated
// symbol table.
func (c *Context) set(name string, value any) error {
	return c.symbols.Set(name, value)
}

// setAlways is a helper function that sets a symbol value in the associated
// symbol table.
func (c *Context) setAlways(name string, value any) {
	c.symbols.SetAlways(name, value)
}

// delete deletes a symbol from the current context.
func (c *Context) delete(name string) error {
	return c.symbols.Delete(name, false)
}

// create creates a symbol.
func (c *Context) create(name string) error {
	return c.symbols.Create(name)
}

// push puts a new items on the stack.
func (c *Context) push(value any) error {
	if c.stackPointer >= len(c.stack) {
		c.stack = append(c.stack, make([]any, growStackBy)...)
	}

	c.stack[c.stackPointer] = value
	c.stackPointer = c.stackPointer + 1

	if c.stackPointer > int(MaxStackSize) {
		atomic.StoreInt32(&MaxStackSize, int32(c.stackPointer))
	}

	return nil
}

// checkType is a utility function used to determine if a given value
// could be stored in a named symbol. When the value is nil or dynamic
// type checking is enabled (the default) then no action occurs.
//
// Otherwise, the symbol name is used to look up the current value (if
// any) of the symbol. If it exists, then the type of the value being
// proposed must match the type of the existing value.
func (c *Context) checkType(name string, value any) (any, error) {
	var (
		canCoerce bool
		err       error
	)

	if constant, ok := value.(data.Immutable); ok {
		value = constant.Value
		canCoerce = true
	}

	if c.typeStrictness == defs.NoTypeEnforcement || value == nil {
		return value, nil
	}

	if existingValue, ok := c.get(name); ok {
		if existingValue == nil {
			return value, nil
		}

		if _, ok := existingValue.(symbols.UndefinedValue); ok {
			return value, nil
		}

		if c.typeStrictness == defs.RelaxedTypeEnforcement {
			newT := data.TypeOf(value)
			oldT := data.TypeOf(existingValue)

			if newT.IsIntegerType() && oldT.IsIntegerType() {
				value, err = data.Coerce(value, existingValue)
				if err != nil {
					return nil, c.runtimeError(err)
				}
			}

			if newT.IsFloatType() && oldT.IsFloatType() {
				value, err = data.Coerce(value, existingValue)
				if err != nil {
					return nil, c.runtimeError(err)
				}
			}
		} else if c.typeStrictness == defs.StrictTypeEnforcement && canCoerce {
			newT := data.TypeOf(value)
			ok := newT.IsFloatType() || newT.IsIntegerType()

			oldT := data.TypeOf(existingValue)

			if ok && (oldT.IsIntegerType() || oldT.IsFloatType()) {
				value, err = data.Coerce(value, existingValue)
				if err != nil {
					return nil, c.runtimeError(err)
				}
			}

			if reflect.TypeOf(value) != reflect.TypeOf(existingValue) {
				rt := data.KindOf(existingValue)
				if rt != data.InterfaceKind {
					return nil, c.runtimeError(errors.ErrInvalidVarType)
				}

				return any(value), nil
			}
		}

		if reflect.TypeOf(value) != reflect.TypeOf(existingValue) {
			return nil, c.runtimeError(errors.ErrInvalidVarType)
		}
	}

	return value, nil
}

func (c *Context) Result() any {
	return c.result
}

func (c *Context) popSymbolTable() error {
	if c.symbols.IsRoot() {
		ui.Log(ui.SymbolLogger, "symbols.nil.parent", ui.A{
			"thread": c.threadID,
			"table":  c.symbols.Name})

		return errors.ErrInternalCompiler.Context("Attempt to pop root table")
	}

	if c.symbols == c.symbols.Parent() {
		return errors.ErrInternalCompiler.Context("Symbol Table Cycle Error")
	}

	c.symbols.DiscardEphemera()

	name := c.symbols.Name
	c.symbols = c.symbols.Parent()

	for strings.HasPrefix(c.symbols.Name, "pkg func ") {
		if c.symbols.IsRoot() {
			break
		}

		c.symbols = c.symbols.Parent()
	}

	ui.Log(ui.SymbolLogger, "symbols.pop.table", ui.A{
		"thread": c.threadID,
		"name":   name,
		"child":  c.symbols.Name})

	return nil
}

// unwrapConstant is a utility function that unwraps a constant
// value. If the value isn't a constant, it returns the original
// value.
func (c *Context) unwrapConstant(v any) any {
	if constant, ok := v.(data.Immutable); ok {
		return constant.Value
	}

	return v
}
