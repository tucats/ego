# bytecode

The `bytecode` package supports a bytecode interpreter. This bytecode interpreter
assumes dynamic binding of all anmes, so it does not require a linkage phase.

## Example

Here is a trivial example of generating bytecode and executing it.

    // Create a ByteCode object and write some instructions into it.
    b := bytecode.New("sample program")
    b.Emit(bytecode.Load, "strings")
    b.Emit(bytecode.Member, "Left")
    b.Emit{bytecode.Push, "fruitcake")
    b.Emit(bytecode.Push, 5)
    b.Emit(bytecode.Call, 2)
    b.Emit(bytecode.Stop)

    // Make a symbol table, so we can call the function library.
    s := symbols.NewSymbolTable("sample program")
    functions.AddBuiltins(s)

    // Make a runtime context for this bytecode, and then run it.
    // The context has the symbol table and bytecode attached to it.
    c := bytecode.NewContext(s, b)
    err := c.Run()

    // Retrieve the last value and extract a string 
    v, err := b.Pop()
    fmt.Printf("The result is %s\n", data.GetString(v))

This creates a new bytecode stream, and then adds instructions to it. These
instructions would nominally be added by the compiler when using _Ego_. The
`Emit()` function emits an instruction with optional opcodes.

The generated bytecode puts arguments to a function on a stack, and then
calls the function. The result is left on the stack, and can be popped off
after execution completes. The result (which is always an abstract
interface{}) is then converted to a string and printed.
